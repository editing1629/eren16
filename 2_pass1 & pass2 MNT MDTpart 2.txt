#include<stdio.h>
#include<stdlib.h>
#include<string.h>


struct Mnemonic_Table
{
	int opcode;
	char mnemonic[10];
};


struct Assembly_Program
{
	char label[10], opcode[10], operand[10];
};


struct Symbol_Table
{
	char symbol[10];
	int address;
};


struct Literal_Table
{
	char literal[10];
	int address;
};


struct Machine_Language
{
	int opcode;
	int reg_operand;
	int mem_operand;
};


struct Register_Operand
{
	int opcode;
	char reg[10];
};

void Read_Instruction(char *, char *, int);
void main()
{
	FILE *fp;
	struct Mnemonic_Table MT[20];
	struct Assembly_Program AP[20];
	struct Symbol_Table ST[20];
	struct Literal_Table LT[20];
	struct Register_Operand RO[10];
	struct Machine_Language ML[20];

	char c, str[10], a[1000], str1[10], str2[10];
	int i, j, k, len, l, flag;
	int no_of_mnemonic;
	int no_of_symbols;
	int no_of_literals;
	
	
	fp = fopen("Mnemonic_Table.txt", "r");
	c = fgetc(fp);
	i = 0;
	while(c != EOF)
	{
		a[i++] = c;
		c = fgetc(fp);
	}
	fclose(fp);
	len = i;	
	k = 0;
	j = 0;
	
	while(k < len)
	{
		
		i = 0;
		while(a[k] != '\t')
			str[i++] = a[k++];
		str[i] = '\0';
		MT[j].opcode = atoi(str);
		k++;

		i = 0;
		while(a[k] != '\n')
			str[i++] = a[k++];			
		str[i] = '\0';
		strcpy(MT[j].mnemonic, str);
		j++;
		k++;
	}
	no_of_mnemonic = j;
	printf("\n\n The Mnemonic Table is");
	printf("\n -------------------------------");
	printf("\n Opcode \t Mnemonic Instruction ");
	printf("\n -------------------------------");
	for(i = 0; i<j; i++)
		printf("\n %d \t %s", MT[i].opcode, MT[i].mnemonic);
	

	
	fp = fopen("Register_Operand.txt", "r");
	c = fgetc(fp);
	i = 0;
	while(c != EOF)
	{
		a[i++] = c;
		c = fgetc(fp);
	}
	fclose(fp);
	len = i;	
	k = 0;
	j = 0;
	
	while(k < len)
	{
		
		i = 0;
		while(a[k] != '\t')
			str[i++] = a[k++];
		str[i] = '\0';
		RO[j].opcode = atoi(str);
		k++;

		i = 0;
		while(a[k] != '\n')
			str[i++] = a[k++];			
		str[i] = '\0';
		strcpy(RO[j].reg, str);
		j++;
		k++;
	}
	printf("\n\n The Register Operands are");
	printf("\n -------------------------------");
	printf("\n Opcode \t Register ");
	printf("\n -------------------------------");
	for(i = 0; i<j; i++)
		printf("\n %d \t %s", RO[i].opcode, RO[i].reg);


	
	fp = fopen("Symbol_Table.txt", "r");
	c = fgetc(fp);
	i = 0;
	while(c != EOF)
	{
		a[i++] = c;
		
		c = fgetc(fp);
	}
	fclose(fp);
	len = i;	
	k = 0;
	j = 0;

	while(k < len)
	{
		
		i = 0;
		while(a[k] != '\t')
			str[i++] = a[k++];
		str[i] = '\0';
		
		strcpy(ST[j].symbol,str);
		k++;

		i = 0;
		while(a[k] != '\n')
			str[i++] = a[k++];			
		str[i] = '\0';
		ST[j].address = atoi(str);
		
		j++;
		k++;
	}
	no_of_symbols = j;
	printf("\n\n The Symbol Table is");
	printf("\n -------------------------------");
	printf("\n Symbol \t Address ");
	printf("\n -------------------------------");
	for(i = 0; i<j; i++)
		printf("\n %s \t %d", ST[i].symbol, ST[i].address);


	
	fp = fopen("Literal_Table.txt", "r");
	c = fgetc(fp);
	i = 0;
	while(c != EOF)
	{
		a[i++] = c;
		
		c = fgetc(fp);
	}
	fclose(fp);
	len = i;	
	k = 0;
	j = 0;

	while(k < len)
	{
		
		i = 0;
		while(a[k] != '\t')
			str[i++] = a[k++];
		str[i-1] = '\0';
		
		strcpy(LT[j].literal,str);
		k++;

		i = 0;
		while(a[k] != '\n')
			str[i++] = a[k++];			
		str[i] = '\0';
		LT[j].address = atoi(str);
		
		j++;
		k++;
	}
	no_of_literals = j;
	printf("\n\n The Literal Table is");
	printf("\n -------------------------------");
	printf("\n Literal \t Address ");
	printf("\n -------------------------------");
	for(i = 0; i<j; i++)
		printf("\n %s \t %d", LT[i].literal, LT[i].address);


	
	fp=fopen("Assembly_Program2.txt","r");	
	c=fgetc(fp);
	i=0;
	printf ("\n\n SOURCE PROGRAM ");
	while(c!=EOF)
	{
		a[i++]=c;
		c=fgetc(fp);
	}
	fclose(fp);
	
	i = 0;
	k = 0;
	j = 0;
	while(1)	
	{
		Read_Instruction(a, str, i);
		strcpy(AP[k].label, str);	
		if(strcmp(str, " ") == 0)
			i = i + strlen(str);
		else
		{
			i = i + strlen(str);
			i++;
		}
		Read_Instruction(a, str, i);
		strcpy(AP[k].opcode, str);	
		if(strcmp(str, " ") == 0)
			i = i + strlen(str);
		else
		{
			i = i + strlen(str);
			i++;
		}
		if(strcmp(AP[k].opcode,"END")==0)
		{
			k++;
			break;
		}
		if(a[i-1] != '\n')
		{
			Read_Instruction(a, str, i);
			strcpy(AP[k].operand, str);	
			i = i + strlen(str);
			i++;
		}
		else
			strcpy(AP[k].operand, " ");
		
		if(strcmp(AP[k].opcode, "START") ==0)
		{
			ML[k].opcode = -1;
			ML[k].reg_operand = -1;
			ML[k].mem_operand = -1;
		}
		else
		{
			
			
			if(strcmp(AP[k].opcode, "DC") != 0 && strcmp(AP[k].opcode, "DS") != 0 && strcmp(AP[k].opcode, "LTORG") != 0 && strcmp(AP[k].opcode, "ORIGIN") != 0 && strcmp(AP[k].opcode, "EQU") != 0 && strcmp(AP[k].opcode, "STOP") != 0 )
			{
				
				for(j = 0; j<no_of_mnemonic; j++)
				{
					if(strcmp(MT[j].mnemonic, AP[k].opcode) == 0)
					{
						ML[k].opcode = MT[j].opcode;
						break;
					}
				}
				strcpy(str, AP[k].operand);

				
				if(strcmp(str, " ") != 0)
				{
					
					j = 0;
					while(str[j] != '\0')
					{
						if(str[j] == ',')
							break;
						str1[j] = str[j];
						j++;
					}
					str1[j] = '\0';
					

					
					l = 0;
					j++;
					if(str[j] != '\0')
					{
						while(str[j] != '\0')
						{
							str2[l] = str[j];
							l++;
							j++;
						}
						str2[l] = '\0';
					}
					else
						strcpy(str2, str1);
					
					flag = 0;
					for(j = 0; j<4; j++)
					{
						if(strcmp(str1, RO[j].reg) == 0)
						{
							ML[k].reg_operand = RO[j].opcode;
							flag = 1;
							break;
						}
					}
					if(flag == 0)
						ML[k].reg_operand = 0;
					
					if(str2[0] != '=')
					{
						flag = 0;
						for(j = 0; j<no_of_symbols; j++)
						{
							if(strcmp(str2, ST[j].symbol) == 0)
							{
								ML[k].mem_operand = ST[j].address;
								flag = 1;
								break;
							}
						}
						if(flag == 0)
							ML[k].mem_operand = 0;
					}
					else
					{
						flag = 0;
						for(j = 0; j<no_of_literals; j++)
						{
							if(strcmp(str2, LT[j].literal) == 0)
							{
								
								ML[k].mem_operand = LT[j].address;
								flag = 1;
								break;
							}
							
						}
						if(flag == 0)
							ML[k].mem_operand = 0;
					}
				}
			}
			else
			{
				ML[k].opcode = -1;
				ML[k].reg_operand = -1;
				ML[k].mem_operand = -1;
			}
		}
		
		k++;
	}
	printf("\n ------------------------------------------- ");
	printf("\n Label\tOpcode\tOperand\tMachine Code");
	printf("\n -------------------------------------------\n ");
	for(i = 0; i<k-1; i++)
		printf("%s\t%s\t%s \t\t %2d %d %3d\n",AP[i].label,AP[i].opcode,AP[i].operand, ML[i].opcode, ML[i].reg_operand, ML[i].mem_operand);
	
}
void Read_Instruction(char a[], char str[], int i)
{
	int j = 0;
	if(a[i]=='\t' || a[i]=='\n')	
		strcpy(str," ");
	else	
	{
		j=0;
		while(1)
		{
			if(a[i]=='\t' || a[i]=='\n')
				break;
			str[j]=a[i];
			i++;
			j++;
		}
		str[j]='\0';
		
	}

create file-Literal_Table.txt

='5' 	 206 
='1' 	 207 
='1' 	 203

            Mnemonic_Table.txt

00	STOP
01	ADD
02	SUB
03	MULT
04	MOVER
05	MOVEM
06	COMP
07	BC
08	DIV
09	READ
10	PRINT


             Register_Operand.txt

1	AREG
2	BREG
3	CREG
4	DREG

             Symbol_Table.txt

LOOP	202
NEXT	209
LAST	211
A	217
BACK	218
B	202